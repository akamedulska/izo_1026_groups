[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This page contains an analysis of isocratic chromatographic data published in the article:\nPaweł Wiczling, Agnieszka Kamedulska, Łukasz Kubik, 2021, “Application of Bayesian Multilevel Modeling in Quantitative Structure-Retention Relationship Studies of Heterogeneous Compounds”, Analytical Chemistry, 93 (18): 6961-6971."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All CodeView Source\n\n\n\n\nData\nWe used a publicly available dataset that comprises the measurements of RP-HPLC retention times collected for 1026 analytes. The retention times were measured under isocratic conditions on Eclipse Plus C18 (Agilent) stationary phase with 3.5 μm particles. The experiments were conducted using a mixture of two solvents: solvent A, which was made of 0.1% formic acid in water, and solvent B, which was made of 0.1% formic acid in acetonitrile. The column temperature was set at 35^{}C. The data were collected by Boswell et al. and were used to create a method to predict retention time by Back-Calculating the Gradient.\n\n\nCode\n# load packages\nlibrary(here)\nlibrary(ggplot2)\n\n# load data\nDS        &lt;- read.csv(here::here(\"1_data/database_stan_1026.csv\"),header = TRUE, sep = \";\", dec = \".\")\nDS_names  &lt;- read.csv(here::here(\"1_data/database_stan_1026_analyte_names.csv\"),header = TRUE, sep = \",\", dec = \".\")\n\n# divide the analytes into groups according to MM\nDS$MM_group &lt;- with(DS, ifelse(MW_ACD &lt; 200, \"1\",\n                                 ifelse(MW_ACD &lt; 300 & MW_ACD &gt;= 200, \"2\", \n                                        ifelse(MW_ACD &lt; 400 & MW_ACD &gt;= 300, \"3\", \"4\" ))))\nlab &lt;- function(x){\n  ifelse(x == 1, \"MM &lt; 200\",\n         ifelse(x == 2, \"200 \\u2264 MM &lt; 300\", \n                ifelse(x == 3, \"300 \\u2264 MM &lt; 400\", \"400 \\u2264 MM\" )))\n}\n\nnObs &lt;- length(DS$ID)\nnAnalytes &lt;- length(unique(DS$ID))\nfi &lt;- seq(0,1,0.1)\n\nggplot(data=DS, aes(x=concentration, y=logk, group=ID)) + \n  geom_line(aes(color=ID)) + \n  facet_wrap(~MM_group, ncol=2, labeller=labeller(MM_group = lab)) +\n  labs(x = expression(varphi), y = expression(Log~k[Obs])) + \n  theme_gray(base_size = 14) + theme(legend.position=\"none\") \n\n\n\n\n\nThe pH value of the mobile phase was verified experimentally for the purpose of this work. It equaled 2.66 with a standard deviation of 0.19 for the range of acetonitrile contents from 5 to 95%.\n\n\nCode\nDS_pH &lt;- read.csv(here::here(\"1_data/pH.csv\"),header = TRUE, sep = \";\", dec = \",\")\n\n\nggplot(data=DS_pH, aes(x=fi, y=pH)) + labs(x = expression(varphi), y = \"pH\") + \n  geom_point() + geom_hline(yintercept=mean(DS_pH$pH), color = \"red\") +\n  geom_hline(yintercept=mean(DS_pH$pH)-sd(DS_pH$pH), linetype=\"dashed\", color = \"red\") +\n  geom_hline(yintercept=mean(DS_pH$pH)+sd(DS_pH$pH), linetype=\"dashed\", color = \"red\") + ylim(c(2.0,3.5))\n\n\n\n\n\nThe values of molecular mass MM were added to the dataset. They were calculated using ACD/Labs program based on the provided structures of analytes. The MM ranged from 73.09 to 656.8.\n\n\nCode\nlibrary(tidyverse)\n\ndf &lt;- DS %&gt;% distinct(ID,MW_ACD) %&gt;%\n  gather(MW_ACD, key= ACD, value=\"value\") %&gt;%\n  mutate(ACD = recode(ACD, \"MW_ACD\" = \"MM\"))\n\nggplot(data= df , aes(x=ACD, y=value))+\n  geom_boxplot(aes(1))+facet_wrap(~ ACD,scales = \"free\") +\n  theme(axis.title.x=element_blank(),\n        axis.text.x=element_blank(),\n        axis.ticks.x=element_blank())\n\n\n\n\n\nInformation on the functional groups of individual compounds has also been added to the data.\n\n\nCode\nfunctional_groups         &lt;- read.csv(here::here(\"1_data/checkmol_nr_groups.csv\"),header = TRUE, sep = \",\", dec = \".\")\nfunctional_groups_names   &lt;- read.delim(here::here(\"1_data/checkmol_functional_group_names.csv\"),header = TRUE, sep = \";\", dec = \".\")\n\n\nThis information was first prepared for analysis in several steps:\n\ncombine nr of caroboxylic acid and carboxyalic acid salt functional groups\n\n\n\nCode\nfunctional_groups[,76]=functional_groups[,76]+functional_groups[,77]       \nfunctional_groups[which(functional_groups[,202]&gt;8.1),202] = 8; # heterocyclic compounds with more than 8 heterocycles are treated as if they have eigth\n\n\n\nexclude functional groups that repeat itself (some groups are nested)\n\n\n\nCode\nidx_excluded &lt;- c(1, 2, 3, 6, 27, 28, 37, 47, 48, 51, 55, 61, 62, 67, 73, 74, 75, 77, 80, 91, 99, 109, 116, 117, 121, 125, 129, 142, 153, 154, 160, 161, 168, 173, 178, 181, 182, 186, 187, 191, 196)\nfunctional_groups_names[which(functional_groups_names$ID_group %in% idx_excluded),2]\n\n\n [1] \"cation\"                      \"anion\"                      \n [3] \"carbonyl compound\"           \"thiocarbonyl compound\"      \n [5] \"hydroxy\"                     \"alcohol\"                    \n [7] \"ether\"                       \"amine\"                      \n [9] \"prim. amine\"                 \"sec. amine\"                 \n[11] \"tert. amine\"                 \"halogen deriv.\"             \n[13] \"alkyl halide\"                \"aryl halide\"                \n[15] \"organolithium compound\"      \"organomagnesium compound\"   \n[17] \"carboxylic acid deriv.\"      \"carboxylic acid salt\"       \n[19] \"carboxylic acid amide\"       \"acyl halide\"                \n[21] \"thiocarboxylic acid deriv.\"  \"orthocarboxylic acid deriv.\"\n[23] \"CO2 deriv.\"                  \"carbonic acid deriv.\"       \n[25] \"thiocarbonic acid deriv.\"    \"carbamic acid deriv\"        \n[27] \"thiocarbamic acid deriv.\"    \"diazonium salt\"             \n[29] \"sulfuric acid deriv.\"        \"sulfuric acid\"              \n[31] \"sulfuryl halide\"             \"sulfonic acid deriv.\"       \n[33] \"sulfinic acid deriv.\"        \"sulfenic acid deriv.\"       \n[35] \"thiol\"                       \"phosphoric acid deriv.\"     \n[37] \"phosphoric acid\"             \"thiophosphoric acid deriv.\" \n[39] \"thiophosphoric acid\"         \"phosphonic acid deriv.\"     \n[41] \"boronic acid deriv.\"        \n\n\nCode\nfunctional_groups &lt;- functional_groups[,-idx_excluded]\nfunctional_groups_names &lt;- functional_groups_names[-idx_excluded,]\n\n\n\nexclude functional groups not present on any analyte from the dataset\n\n\n\nCode\nidx_not_present = which(colSums(functional_groups==0) == nrow(functional_groups))\nfunctional_groups_names[which(functional_groups_names$ID_group %in% idx_not_present),2]\n\n\n [1] \"aldehyde\"                       \"thioketone\"                    \n [3] \"imine\"                          \"semicarbazone\"                 \n [5] \"oxime\"                          \"acetal\"                        \n [7] \"sec. alcohol\"                   \"enediol\"                       \n [9] \"sec. mixed amine (aryl alkyl)\"  \"aryl bromide\"                  \n[11] \"organometallic compound\"        \"carboxylic acid\"               \n[13] \"carboxylic acid ester\"          \"lactone\"                       \n[15] \"carboxylic acid prim. amide\"    \"carboxylic acid tert. amide\"   \n[17] \"lactam\"                         \"carboxylic acid azide\"         \n[19] \"carboxylic acid amidine\"        \"carboxylic acid amidrazone\"    \n[21] \"nitrile\"                        \"acyl bromide\"                  \n[23] \"acyl cyanide\"                   \"imidoyl halide\"                \n[25] \"thiolactone\"                    \"imido_thioester\"               \n[27] \"carboxylic acid anhydride\"      \"carboxylic acid unsubst. imide\"\n[29] \"carboxylic acid subst. imide\"   \"carbonic acid monoester\"       \n[31] \"carbonic acid ester halide\"     \"thiocarbonic acid diester\"     \n[33] \"thiocarbonic acid ester halide\" \"carbamic acid\"                 \n[35] \"carbamic acid halide\"           \"thiocarbamic acid ester\"       \n[37] \"isothiourea\"                    \"guanidine\"                     \n[39] \"semicarbazide\"                  \"thiosemicarbazide\"             \n[41] \"azide\"                          \"azo compound\"                  \n[43] \"isonitrile\"                     \"cyanate\"                       \n[45] \"isothiocyanate\"                 \"nitro compound\"                \n[47] \"sulfuric acid monoester\"        \"sulfuric acid diester\"         \n[49] \"sulfuric acid amide ester\"     \n\n\nCode\nfunctional_groups &lt;- functional_groups[,-idx_not_present]\nfunctional_groups_names &lt;- functional_groups_names[-idx_not_present,]\n\n\nThe functional groups present in the analyzed chemical compounds are presented below, along with their frequencies\n\n\nCode\nsumdata=data.frame(value=apply(functional_groups,2,sum))\nsumdata$key=functional_groups_names[,2]\nsumdata &lt;- sumdata[order(sumdata$value),]\nsumdata$split &lt;- rep(c(1,2),each=50)\n\nlayout(c(1,2), widths=c(1,3))\n\np1 &lt;- ggplot(data=sumdata[which(sumdata$split==1),], aes(x=reorder(key, +value), y=value, fill=key)) +\n  geom_bar(fill=\"blue\", stat=\"identity\") + \n  theme(legend.position = \"none\",\n        axis.title.x=element_blank(),\n        axis.title.y=element_blank()) + \n  coord_flip()+\n  scale_y_continuous(breaks=c(0,5,10))\n\np2 &lt;- ggplot(data=sumdata[which(sumdata$split==2),], aes(x=reorder(key, +value), y=value, fill=key)) +\n  geom_bar(fill=\"blue\", stat=\"identity\") + \n  theme(legend.position = \"none\",\n        axis.title.x=element_blank(),\n        axis.title.y=element_blank()) + \n  coord_flip() + scale_y_continuous(trans='log10',breaks=c(0,10,100,1000))\n\nlibrary(patchwork)\n\n# Custom design (# means empty area)\ndesign &lt;- \"\n  1222\n\"\n\n# Combine the plots with a custom layout\np1 + p2 +\n  plot_layout(design = design)"
  },
  {
    "objectID": "evaluation.html",
    "href": "evaluation.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All CodeView Source"
  },
  {
    "objectID": "evaluation.html#goodness-of-fit",
    "href": "evaluation.html#goodness-of-fit",
    "title": "",
    "section": "Goodness of fit",
    "text": "Goodness of fit\n\n\nCode\nlogkCond &lt;- fit$draws('logkCond', format = \"df\")[,-c(5098:5100)]\nlogkPred &lt;- fit$draws('logkPred', format = \"df\")[,-c(5098:5100)]\n\npar(mfrow=c(1,2))\nplot(apply(logkCond,2,mean),DS$logk,cex.lab=1.2,xlim=c(-4,6),ylim=c(-3,3),pch=20,col=\"blue\",ylab=expression(\"Log k\"[Obs]),xlab=expression(\"Log k\"[Pred]))\nlines(seq(-4,6,by=0.1),seq(-4,6,by=0.1),lwd=2)\nplot(apply(logkPred,2,mean),DS$logk,cex.lab=1.2,xlim=c(-4,6),ylim=c(-3,3),pch=20,col=\"blue\",ylab=expression(\"Log k\"[Obs]),xlab=expression(\"Log k\"[Pred]))\nlines(seq(-4,6,by=0.1),seq(-4,6,by=0.1),lwd=2)\n\n\n\n\n\n\nWAIC\n\n\nCode\nloo_result &lt;- fit$loo(cores = 2)\nprint(loo_result)\n\n\n\nComputed from 4000 by 5097 log-likelihood matrix\n\n         Estimate    SE\nelpd_loo   7847.5 101.4\np_loo      5335.9  70.9\nlooic    -15695.1 202.8\n------\nMonte Carlo SE of elpd_loo is NA.\n\nPareto k diagnostic values:\n                         Count Pct.    Min. n_eff\n(-Inf, 0.5]   (good)     4298  84.3%   5         \n (0.5, 0.7]   (ok)        551  10.8%   24        \n   (0.7, 1]   (bad)       170   3.3%   9         \n   (1, Inf)   (very bad)   78   1.5%   1         \nSee help('pareto-k-diagnostic') for details."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Application of Bayesian Multilevel Modeling in Quantitative Structure-Retention Relationship Studies of Heterogeneous Compounds",
    "section": "",
    "text": "Introduction\nQuantitative structure−retention relationships (QSRRs) are used in the field of chromatography to model the relationship between an analyte structure and chromatographic retention. Such models are typically difficult to build and validate for heterogeneous compounds because of their many descriptors and relatively limited analyte-specific data.\nIn this study, a Bayesian multilevel model is proposed to characterize the isocratic retention time data collected for 1026 heterogeneous analytes. The QSRR considers the effects of the molecular mass and 100 functional groups (substituents) on analyte-specific chromatographic parameters of the Neue model (i.e., the retention factor in water, the retention factor in acetonitrile, and the curvature coefficient). A Bayesian multilevel regression model was used to smooth noisy parameter estimates with too few data and to consider the uncertainties in the model parameters.\nWe discuss the benefits of the Bayesian multilevel model: 1) to understand chromatographic data, 2) to quantify the effect of functional groups on chromatographic retention, 3) to predict analyte retention based on various types of preliminary data.\nThe uncertainty of isocratic and gradient predictions was visualized using uncertainty chromatograms and discussed in terms of usefulness in decision making. We think that this method will provide the most benefit in providing a unified scheme for analyzing large chromatographic databases and assessing the impact of functional groups and other descriptors on analyte retention."
  },
  {
    "objectID": "model.html",
    "href": "model.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All CodeView Source"
  },
  {
    "objectID": "model.html#priors",
    "href": "model.html#priors",
    "title": "",
    "section": "Priors",
    "text": "Priors\nIn this work were used weakly uninformative priors:\n\\[\\begin{align*}\n\\nu_{obs} \\sim Gamma(2,0.1),\\\\\n\\sigma \\sim N_+(0,0.067),\\\\\n\\\\\n\\nu \\sim Gamma(2,0.1),\\\\\n\\theta_{\\log k_{w}} \\sim N(6.6,1.5),  \\quad \\theta_{\\log k_{a}} \\sim N(1.3,1.5),\\\\\n\\theta_{\\log S_{2}},  \\sim N(\\log 2,0.2), \\\\\n\\beta_{\\log k_{w}} \\sim N(1.4,1.5), \\quad\n\\beta_{\\log k_{a}} \\sim N(0.2,1.5), \\\\\n\\beta_{\\log S_{2}} \\sim N(0,0.2), \\\\\n\\omega_{\\log k_{w}} \\sim N_+(0,1.5),\\\\\n\\omega_{\\log k_{a}} \\sim N_+(0,1.5),\\\\\n\\omega_{\\log S_{2}} \\sim N_+(0,0.2),\\\\\n\\begin{bmatrix}\n1 & \\rho_{1,2} & \\rho_{1,3} \\\\\n\\rho_{2,1} & 1 & \\rho_{2,3} \\\\\n\\rho_{3,1} & \\rho_{3,2} & 1\n\\end{bmatrix} \\sim \\text{LKJ}(1), \\\\\n\\\\\n\\theta_{\\pi \\log k_w}\\sim N_+(0,1.5), \\quad \\theta_{\\pi d\\log k}\\sim N_(0,1.5),\\\\\n\\sigma_{\\pi\\log k_w},\\sigma_{\\pi d\\log k}\\sim N_+(0,1.5),\\sigma_{\\pi \\log S_2}\\sim N_+(0,0.2)\\\\\n\\nu_{\\pi} \\sim Gamma(2,0.1).\\\\\n\\end{align*}\\]"
  },
  {
    "objectID": "model.html#code-for-stan",
    "href": "model.html#code-for-stan",
    "title": "",
    "section": "Code for Stan",
    "text": "Code for Stan\nAt the beginning, a model was constructed and implemented in the Stan program.\n\n\nCode\nfunctions{\n  real hplcmodel(real fi, real logkw, real logka, real logS2){\n    \n    real logk;                                              // retention factor\n    real S1;\n    \n    S1 = (logkw - logka)*(1+10^logS2);\n    logk = logkw - S1 * fi / (1 + 10^logS2 * fi);\n    \n    return logk;\n  }\n}\n\ndata{\n  int nAnalytes;    // number of analytes\n  int nObs;         // number of observations\n  int analyte[nObs];        // analytes indexes\n  int start[nAnalytes];     // first apperance of analyte in \"analyte\" vector\n  vector[nObs] logkObs;     // observed retention factors\n  vector[nObs] fi;         // organic modifier content in the mobile phase\n  real Mmolx[nObs];         // (moleculuar mass-300)/100\n  int&lt;lower=0&gt; K;           //  number of predictors (functional groups)\n  matrix[nAnalytes, K] nrfungroups;   // predictor matrix (functional groups)   \n  int&lt;lower = 0, upper = 1&gt; run_estimation; // 0 for prior predictive, 1 for estimation\n}\n\nparameters{\n\n real logkwHat; // mean value of logkw \n real logkaHat; // mean value of logka \n real logS2Hat; // mean curvature coefficient \n real&lt;lower = 0&gt; sigma;     // standard deviation for residuals\n vector&lt;lower = 0&gt;[3] omega;// diagonal elements of variance-covariance matrix for inter-analyte variability \n corr_matrix[3] rho;        // correlation matrix       \n real&lt;lower = 1&gt; nu;        // normality constant for inter-analyte variability \n real&lt;lower = 1&gt; nuobs;     // normality constant for residual variability \n real&lt;lower = 1&gt; nupi;     // normality constant for residual variability \n real beta[3];              // regression coefficients for Mmolx\n vector[3] param[nAnalytes]; // individual values of chromatographic parameters\n vector&lt;lower = 0&gt;[K] pilogkw;  // regression coefficient for logkw\n vector[K] pidlogk ;  //... logka logkw difference\n vector[K] pilogS2;             // ... logS2\n real&lt;lower = 0&gt; spilogkw;      // group-level std for logkw\n real&lt;lower = 0&gt; spidlogk;      //... logka\n real&lt;lower = 0&gt; spilogS2;      //... logS2\n real&lt;lower = 0&gt; mpilogkw;      // group-level mean for logkw\n real mpidlogk;      //... logka\n}\n\ntransformed parameters{\n  vector[3] miu[nAnalytes];  \n  real logka[nAnalytes];\n  real logkw[nAnalytes];\n  real logS2[nAnalytes];\n  vector[K] pilogka;\n  cov_matrix[3] Omega;           // variance-covariance matrix\n  vector[nObs] logkHat;     \n\n  Omega = quad_form_diag(rho, omega);   // diag_matrix(omega) * rho * diag_matrix(omega)\n\n  pilogka = pilogkw - pidlogk;\n\n  for(j in 1:nAnalytes){\n    miu[j,1]  = logkwHat + beta[1] * Mmolx[start[j]] - nrfungroups[j,1:K] * pilogkw;\n    miu[j,2]  = logkaHat + beta[2] * Mmolx[start[j]] - nrfungroups[j,1:K] * pilogka; \n    miu[j,3]  = logS2Hat + beta[3] * Mmolx[start[j]] + nrfungroups[j,1:K] * pilogS2;\n  }\n\n  for(j in 1:nAnalytes){\n        logkw[j] = param[j, 1];\n        logka[j] = param[j, 2];\n        logS2[j] = param[j, 3];\n }\n  \n  for(i in 1:nObs){\n    logkHat[i] = hplcmodel(fi[i], logkw[analyte[i]], logka[analyte[i]], logS2[analyte[i]]);\n }\n}\nmodel{\n  logkwHat ~ normal(6.6, 1.5);  //3.6+2*1.5\n  logkaHat ~ normal(1.3, 1.5); //-1.7+2*1.5\n  logS2Hat ~ normal(log10(2), 0.2);\n\n  beta[1]  ~ normal(1.4,1.5);\n  beta[2]  ~ normal(0.2,1.5);\n  beta[3]  ~ normal(0,0.2);\n\n  omega[1] ~ normal(0,1.50);\n  omega[2] ~ normal(0,1.50);\n  omega[3] ~ normal(0,0.2);\n\n  rho   ~ lkj_corr(1);\n  sigma  ~ normal(0,0.067);\n\n  mpilogkw ~ normal(0,1.5);\n  mpidlogk ~ normal(0,1.5);\n  \n  spilogkw ~ normal(0,1.5);\n  spidlogk ~ normal(0,1.5);\n  spilogS2 ~ normal(0,0.2);\n\n  pilogkw ~ lognormal(log(mpilogkw),spilogkw);\n  pidlogk ~ student_t(nupi,mpidlogk,spidlogk);\n  pilogS2 ~ normal(0,spilogS2);\n\n  nu    ~ gamma(2,0.1);\n  nuobs ~ gamma(2,0.1);\n  nupi  ~ gamma(2,0.1);\n\n  for(i in  1:nAnalytes){\n  param[i] ~ multi_student_t(nu,miu[i],Omega);\n  }\n  \n  if(run_estimation==1){\n  logkObs ~ student_t(nuobs,logkHat,sigma); // likelihood\n  }\n}\n\ngenerated quantities{\n  real logkCond[nObs];\n  real logkPred[nObs];\n  real log_lik[nObs];\n  vector[3] paramPred[nAnalytes]; \n  \n  for(j in 1:nAnalytes){\n   paramPred[j] = multi_student_t_rng(nu,miu[j],Omega);\n  }\n  \n  for(i in 1:nObs){\n   real logkHatPred;    // predicted logk   \n   logkHatPred = hplcmodel(fi[i], paramPred[analyte[i],1], paramPred[analyte[i],2], paramPred[analyte[i],3]);\n   logkCond[i] = student_t_rng(nuobs, logkHat[i], sigma);\n   logkPred[i] = student_t_rng(nuobs, logkHatPred, sigma);\n   log_lik[i]= student_t_lpdf(logkObs[i] | nuobs, logkHat[i], sigma);\n  }\n}\n\n\nThen, the data was added to it and the initial values of the model parameters were determined. In the end, the model was fitted.\nBelow code preapering data to fit the model in supercomputer:\n\n\nCode\n# load packages\nlibrary(pracma)\nlibrary(dplyr)\nlibrary(ggplot2)\nrequire(gridExtra)\nlibrary(GGally)\nlibrary(cmdstanr)\nlibrary(rstan)\nlibrary(knitr)\nlibrary(reshape2)\nlibrary(bayesplot)\nlibrary(posterior)\n\n# load data\nDS       &lt;- read.csv(here::here(\"1_data/database_stan_1026.csv\"),header = TRUE, sep = \";\", dec = \".\")\nDS_names &lt;- read.csv(here::here(\"1_data/database_stan_1026_analyte_names.csv\"),header = TRUE, sep = \",\", dec = \".\")\nfunctional_groups         &lt;- read.csv(here::here(\"1_data/checkmol_nr_groups.csv\"),header = TRUE, sep = \",\", dec = \".\")\nfunctional_groups_names   &lt;- read.delim(here::here(\"1_data/checkmol_functional_group_names.csv\"),header = TRUE, sep = \";\", dec = \".\")\n\n### prepearing data with functional groups\nfunctional_groups[,76]=functional_groups[,76]+functional_groups[,77]       \nfunctional_groups[which(functional_groups[,202]&gt;8.1),202] = 8; # heterocyclic compounds with more than 8 heterocycles are treated as if they have eigth\n\nidx_excluded &lt;- c(1, 2, 3, 6, 27, 28, 37, 47, 48, 51, 55, 61, 62, 67, 73, 74, 75, 77, 80, 91, 99, 109, 116, 117, 121, 125, 129, 142, 153, 154, 160, 161, 168, 173, 178, 181, 182, 186, 187, 191, 196)\nfunctional_groups &lt;- functional_groups[,-idx_excluded]\nfunctional_groups_names &lt;- functional_groups_names[-idx_excluded,]\n\nidx_not_present = which(colSums(functional_groups==0) == nrow(functional_groups))\nfunctional_groups &lt;- functional_groups[,-idx_not_present]\nfunctional_groups_names &lt;- functional_groups_names[-idx_not_present,]\n\nnAnalytes=length(unique(DS$ID))\nnObs=length(DS$ID)\nanalyte=match(DS$ID, unique(DS$ID))\nstart=which(!duplicated(DS$ID))\nK=ncol(functional_groups)\nMmolx=(DS$MW_ACD-300)/100\nnrfungroups=functional_groups\nlogkObs=DS$logk\nfi=DS$concentration\nrun_estimation=1\n\nstan_rdump(c(\"nAnalytes\", \n             \"nObs\",\n             \"start\", \n             \"analyte\", \n             \"logkObs\", \n             \"fi\",\n             \"K\",\n             \"nrfungroups\",\n             \"Mmolx\",\n             \"run_estimation\"),\n           file=\"2_model/model.data.R\")\n\ninitial_param_A &lt;- matrix(NA,nAnalytes,2)\nfor(i in 1:nAnalytes){\n  initial_param_A[i,] = \n    polyfit(DS$concentration[which(DS$ID==i)]/(1+2*DS$concentration[which(DS$ID==i)]),\n            DS$logk[which(DS$ID==i)],1)\n}\ninitial_param_A = cbind(initial_param_A,rep(2,nAnalytes))\nparam = cbind(initial_param_A[,2], initial_param_A[,2] + initial_param_A[,1]/3, log10(initial_param_A[,3]))\n\nfor(i in 1:10){\n  logkwHat  =  rnorm(1,6.6,1)\n  logkaHat  = rnorm(1,1.3,1)\n  logS2Hat = rnorm(1,log(2),0.1)\n  beta = c(1.4,0.2,0)*exp(rnorm(3,0,1))\n  rho = diag(1,3,3)\n  sigma =rlnorm(1,log(0.05),0.2)\n  nu = rgamma(1,2,shape=1/0.1)\n  nuobs = rgamma(1,2,shape=1/0.1)\n  nupi = rgamma(1,2,shape=1/0.1)\n  pilogkw = rlnorm(K,log(0.2),0.5)\n  pidlogk = rnorm(K,0.2, 0.5)\n  pilogS2 = rnorm(K,0, 0.1)\n  omega= c(1,1,0.1)*exp(rnorm(3,0,0.2))\n  spilogkw= abs(rnorm(1,0,0.5))\n  spidlogk= abs(rnorm(1,0,0.5))\n  spilogS2= abs(rnorm(1,0,0.5))\n  mpilogkw = abs(rnorm(1,0,0.5))\n  mpidlogk = rnorm(1,0,0.5)\n  param  = param\n  \n  stan_rdump(c(\"logkwHat\",\"logkaHat\",\"logS2Hat\",\"beta\",\"rho\",\"sigma\",\n               \"nu\",\"nuobs\",\"nupi\",\"pilogkw\",\"pidlogk\",\"pilogS2\",\"omega\",\n               \"spilogkw\",\"spidlogk\",\"spilogS2\",\"mpilogkw\",\"mpidlogk\",\"param\"),\n             file=paste(\"2_model/model_\", i, \".init.R\", sep=\"\"))\n}"
  },
  {
    "objectID": "model.html#summary-of-estimated-model-parameters",
    "href": "model.html#summary-of-estimated-model-parameters",
    "title": "",
    "section": "Summary of estimated model parameters",
    "text": "Summary of estimated model parameters\nCode for print summary of parameters from supercomputer:\n\n\nCode\nfit &lt;- cmdstanr::as_cmdstan_fit(c('2_model/output_1.csv',\n                                  '2_model/output_2.csv',\n                                  '2_model/output_3.csv',\n                                  '2_model/output_4.csv',\n                                  '2_model/output_5.csv',\n                                  '2_model/output_6.csv',\n                                  '2_model/output_7.csv',\n                                  '2_model/output_8.csv',\n                                  '2_model/output_9.csv',\n                                  '2_model/output_10.csv'))\n\nfit$print(c(\"logkwHat\",\"logkaHat\",\"logS2Hat\",\"beta\",\"rho\",\"sigma\",\"nu\",\"nuobs\",\"nupi\",\"omega\",\n            \"spilogkw\",\"spidlogk\",\"spilogS2\",\"mpilogkw\",\"mpidlogk\"), max_rows = 30)\n\n\nWarning: pojawiły się wartości NA na skutek przekształcenia\n\nWarning: pojawiły się wartości NA na skutek przekształcenia\n\n\n variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n logkwHat  7.07   7.07 0.17 0.17  6.80  7.36 1.01      658     1251\n logkaHat  0.05   0.05 0.07 0.07 -0.07  0.17 1.00     3189     2771\n logS2Hat  0.38   0.38 0.03 0.03  0.34  0.42 1.00     2232     3076\n beta[1]   2.64   2.64 0.08 0.07  2.51  2.76 1.01      915     1959\n beta[2]   0.40   0.40 0.03 0.03  0.35  0.45 1.00     3414     3175\n beta[3]  -0.02  -0.02 0.01 0.01 -0.04  0.00 1.00     1912     3291\n rho[1,1]  1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n rho[2,1]  0.62   0.62 0.03 0.03  0.57  0.66 1.00     2436     3500\n rho[3,1] -0.14  -0.14 0.05 0.05 -0.22 -0.06 1.01     1501     2517\n rho[1,2]  0.62   0.62 0.03 0.03  0.57  0.66 1.00     2436     3500\n rho[2,2]  1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n rho[3,2] -0.27  -0.27 0.05 0.05 -0.35 -0.20 1.00     2015     3561\n rho[1,3] -0.14  -0.14 0.05 0.05 -0.22 -0.06 1.01     1501     2517\n rho[2,3] -0.27  -0.27 0.05 0.05 -0.35 -0.20 1.00     2015     3561\n rho[3,3]  1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n sigma     0.01   0.01 0.00 0.00  0.01  0.01 1.01      781     1975\n nu        2.32   2.31 0.20 0.20  2.02  2.67 1.01     1157     2365\n nuobs     1.33   1.33 0.05 0.05  1.24  1.42 1.01     1422     2702\n nupi      9.87   6.87 8.80 4.93  2.37 27.48 1.01     1773     2556\n omega[1]  0.73   0.73 0.04 0.03  0.67  0.79 1.01     1519     2886\n omega[2]  0.33   0.33 0.02 0.02  0.30  0.36 1.01     1392     3054\n omega[3]  0.12   0.12 0.01 0.01  0.11  0.13 1.00     1686     2973\n spilogkw  0.83   0.83 0.10 0.10  0.69  1.00 1.00     1519     2566\n spidlogk  0.25   0.25 0.05 0.05  0.17  0.33 1.01     1041     2132\n spilogS2  0.07   0.07 0.01 0.01  0.06  0.08 1.00     1635     2527\n mpilogkw  0.49   0.49 0.06 0.06  0.39  0.60 1.01     1022     2419\n mpidlogk  0.38   0.37 0.05 0.05  0.30  0.46 1.01     1027     2026"
  }
]
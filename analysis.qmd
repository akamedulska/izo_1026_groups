# Analysis

At the beginning, a model was constructed and implemented in the Stan program.

```{stan output.var="initial_model", eval = FALSE}
functions{
  real hplcmodel(real fi, real logkw, real logka, real logS2){
    
    real logk;												// retention factor
    real S1;
    
    S1 = (logkw - logka)*(1+10^logS2);
    logk = logkw - S1 * fi / (1 + 10^logS2 * fi);
    
    return logk;
  }
}

data{
  int nAnalytes;	// number of analytes
  int nObs;			// number of observations
  int analyte[nObs];		// analytes indexes
  int start[nAnalytes];		// first apperance of analyte in "analyte" vector
  vector[nObs] logkObs;	    // observed retention factors
  vector[nObs] fi;         // organic modifier content in the mobile phase
  real Mmolx[nObs];         // (moleculuar mass-300)/100
  int<lower=0> K;           //  number of predictors (functional groups)
  matrix[nAnalytes, K] nrfungroups;   // predictor matrix (functional groups)   
  int<lower = 0, upper = 1> run_estimation; // 0 for prior predictive, 1 for estimation
}

parameters{

 real logkwHat;	// mean value of logkw 
 real logkaHat; // mean value of logka 
 real logS2Hat;	// mean curvature coefficient 
 real<lower = 0> sigma;		// standard deviation for residuals
 vector<lower = 0>[3] omega;// diagonal elements of variance-covariance matrix for inter-analyte variability 
 corr_matrix[3] rho;	    // correlation matrix		
 real<lower = 1> nu;	    // normality constant for inter-analyte variability 
 real<lower = 1> nuobs;     // normality constant for residual variability 
 real<lower = 1> nupi;     // normality constant for residual variability 
 real beta[3];			    // regression coefficients for Mmolx
 vector[3] param[nAnalytes]; // individual values of chromatographic parameters
 vector<lower = 0>[K] pilogkw;  // regression coefficient for logkw
 vector[K] pidlogk ;  //... logka logkw difference
 vector[K] pilogS2;             // ... logS2
 real<lower = 0> spilogkw;      // group-level std for logkw
 real<lower = 0> spidlogk;      //... logka
 real<lower = 0> spilogS2;      //... logS2
 real<lower = 0> mpilogkw;      // group-level mean for logkw
 real mpidlogk;      //... logka
}

transformed parameters{
  vector[3] miu[nAnalytes];	 
  real logka[nAnalytes];
  real logkw[nAnalytes];
  real logS2[nAnalytes];
  vector[K] pilogka;
  cov_matrix[3] Omega;			 // variance-covariance matrix
  vector[nObs] logkHat;		

  Omega = quad_form_diag(rho, omega);	// diag_matrix(omega) * rho * diag_matrix(omega)

  pilogka = pilogkw - pidlogk;

  for(j in 1:nAnalytes){
    miu[j,1]  = logkwHat + beta[1] * Mmolx[start[j]] - nrfungroups[j,1:K] * pilogkw;
    miu[j,2]  = logkaHat + beta[2] * Mmolx[start[j]] - nrfungroups[j,1:K] * pilogka; 
    miu[j,3]  = logS2Hat + beta[3] * Mmolx[start[j]] + nrfungroups[j,1:K] * pilogS2;
  }

  for(j in 1:nAnalytes){
		logkw[j] = param[j, 1];
		logka[j] = param[j, 2];
		logS2[j] = param[j, 3];
 }
  
  for(i in 1:nObs){
    logkHat[i] = hplcmodel(fi[i], logkw[analyte[i]], logka[analyte[i]], logS2[analyte[i]]);
 }
}
model{
  logkwHat ~ normal(6.6, 1.5);  //3.6+2*1.5
  logkaHat ~ normal(1.3, 1.5); //-1.7+2*1.5
  logS2Hat ~ normal(log10(2), 0.2);

  beta[1]  ~ normal(1.4,1.5);
  beta[2]  ~ normal(0.2,1.5);
  beta[3]  ~ normal(0,0.2);

  omega[1] ~ normal(0,1.50);
  omega[2] ~ normal(0,1.50);
  omega[3] ~ normal(0,0.2);

  rho   ~ lkj_corr(1);
  sigma  ~ normal(0,0.067);

  mpilogkw ~ normal(0,1.5);
  mpidlogk ~ normal(0,1.5);
  
  spilogkw ~ normal(0,1.5);
  spidlogk ~ normal(0,1.5);
  spilogS2 ~ normal(0,0.2);

  pilogkw ~ lognormal(log(mpilogkw),spilogkw);
  pidlogk ~ student_t(nupi,mpidlogk,spidlogk);
  pilogS2 ~ normal(0,spilogS2);

  nu    ~ gamma(2,0.1);
  nuobs ~ gamma(2,0.1);
  nupi  ~ gamma(2,0.1);

  for(i in  1:nAnalytes){
  param[i] ~ multi_student_t(nu,miu[i],Omega);
  }
  
  if(run_estimation==1){
  logkObs ~ student_t(nuobs,logkHat,sigma); // likelihood
  }
}

generated quantities{
  real logkCond[nObs];
  real logkPred[nObs];
  //real log_lik[nObs];
  vector[3] paramPred[nAnalytes]; 
  
  for(j in 1:nAnalytes){
   paramPred[j] = multi_student_t_rng(nu,miu[j],Omega);
  }
  
  for(i in 1:nObs){
   real logkHatPred;	// predicted logk	
   logkHatPred = hplcmodel(fi[i], paramPred[analyte[i],1], paramPred[analyte[i],2], paramPred[analyte[i],3]);
   logkCond[i] = student_t_rng(nuobs, logkHat[i], sigma);
   logkPred[i] = student_t_rng(nuobs, logkHatPred, sigma);
   //log_lik[i]= student_t_lpdf(logkObs[i] | nuobs, logkHat[i], sigma);
  }
}
```

Then, the data was added to it and the initial values of the model parameters were determined. In the end, the model was fitted.

Below code preapering data to fit the model in supercomputer:

```{r message=FALSE}
# load packages
library(pracma)
library(dplyr)
library(ggplot2)
require(gridExtra)
library(GGally)
library(cmdstanr)
library(rstan)
library(knitr)
library(reshape2)
library(bayesplot)
library(posterior)

# load data
DS       <- read.csv(here::here("1_data/database_stan_1026.csv"),header = TRUE, sep = ";", dec = ".")
DS_names <- read.csv(here::here("1_data/database_stan_1026_analyte_names.csv"),header = TRUE, sep = ",", dec = ".")
functional_groups         <- read.csv(here::here("1_data/checkmol_nr_groups.csv"),header = TRUE, sep = ",", dec = ".")
functional_groups_names   <- read.delim(here::here("1_data/checkmol_functional_group_names.csv"),header = TRUE, sep = ";", dec = ".")

### prepearing data with functional groups
functional_groups[,76]=functional_groups[,76]+functional_groups[,77]       
functional_groups[which(functional_groups[,202]>8.1),202] = 8; # heterocyclic compounds with more than 8 heterocycles are treated as if they have eigth

idx_excluded <- c(1, 2, 3, 6, 27, 28, 37, 47, 48, 51, 55, 61, 62, 67, 73, 74, 75, 77, 80, 91, 99, 109, 116, 117, 121, 125, 129, 142, 153, 154, 160, 161, 168, 173, 178, 181, 182, 186, 187, 191, 196)
functional_groups <- functional_groups[,-idx_excluded]
functional_groups_names <- functional_groups_names[-idx_excluded,]

idx_not_present = which(colSums(functional_groups==0) == nrow(functional_groups))
functional_groups <- functional_groups[,-idx_not_present]
functional_groups_names <- functional_groups_names[-idx_not_present,]

nAnalytes=length(unique(DS$ID))
nObs=length(DS$ID)
analyte=match(DS$ID, unique(DS$ID))
start=which(!duplicated(DS$ID))
K=ncol(functional_groups)
Mmolx=(DS$MW_ACD-300)/100
nrfungroups=functional_groups
logkObs=DS$logk
fi=DS$concentration
run_estimation=1

stan_rdump(c("nAnalytes", 
             "nObs",
             "start", 
             "analyte", 
             "logkObs", 
             "fi",
             "K",
             "nrfungroups",
             "Mmolx",
             "run_estimation"),
           file="2_model/model.data.R")

initial_param_A <- matrix(NA,nAnalytes,2)
for(i in 1:nAnalytes){
  initial_param_A[i,] = 
    polyfit(DS$concentration[which(DS$ID==i)]/(1+2*DS$concentration[which(DS$ID==i)]),
            DS$logk[which(DS$ID==i)],1)
}
initial_param_A = cbind(initial_param_A,rep(2,nAnalytes))
param = cbind(initial_param_A[,2], initial_param_A[,2] + initial_param_A[,1]/3, log10(initial_param_A[,3]))

for(i in 1:10){
  logkwHat  =  rnorm(1,6.6,1)
  logkaHat  = rnorm(1,1.3,1)
  logS2AHat = rnorm(1,log(2),0.1)
  beta = c(1.4,0.2,0)*exp(rnorm(3,0,1))
  rho = diag(1,3,3)
  sigma =rlnorm(1,log(0.05),0.2)
  nu = rgamma(1,2,1/0.1)
  nuobs = rgamma(1,2,1/0.1)
  nupi = rgamma(1,2,1/0.1)
  pilogkw = rlnorm(K,log(0.2),0.5)
  pidlogk = rnorm(K,0.2, 0.5)
  pilogS2 = rnorm(K,0, 0.1)
  omega= c(1,1,0.1)*exp(rnorm(3,0,0.2))
  spilogkw= abs(rnorm(1,0,0.5))
  spidlogk= abs(rnorm(1,0,0.5))
  spilogS2= abs(rnorm(1,0,0.5))
  mpilogkw = abs(rnorm(1,0,0.5))
  mpidlogk = rnorm(1,0,0.5)
  param  = param
  
  stan_rdump(c("logkwHat","logkaHat","logS2AHat","beta","rho","sigma",
               "nu","nuobs","nupi","pilogkw","pidlogk","pilogS2","omega",
               "spilogkw","spidlogk","spilogS2","mpilogkw","mpidlogk","param"),
             file=paste("2_model/model_", i, ".init.R", sep=""))
}
```

## Summary of model parameters

Code for print summary of parameters from supercomputer:

```{r eval=FALSE}
fit <- cmdstanr::as_cmdstan_fit(c('2_model/output_1.csv',
                                  '2_model/output_2.csv',
                                  '2_model/output_3.csv',
                                  '2_model/output_4.csv',
                                  '2_model/output_5.csv',
                                  '2_model/output_6.csv',
                                  '2_model/output_7.csv',
                                  '2_model/output_8.csv',
                                  '2_model/output_9.csv',
                                  '2_model/output_10.csv'))

fit$print(c("logkwHat","logkaHat","logS2AHat","beta","rho","sigma","nu","nuobs","nupi","omega",
            "spilogkw","spidlogk","spilogS2","mpilogkw","mpidlogk"), max_rows = 26)
```


{
  "hash": "d6dc6e9fb90003b3df1494e39902a6d0",
  "result": {
    "markdown": "# Analysis\n\nAt the beginning, a model was constructed and implemented in the Stan program.\n\n\n::: {.cell output.var='initial_model'}\n\n```{.stan .cell-code}\nfunctions{\n  real hplcmodel(real fi, real logkw, real logka, real logS2){\n    \n    real logk;\t\t\t\t\t\t\t\t\t\t\t\t// retention factor\n    real S1;\n    \n    S1 = (logkw - logka)*(1+10^logS2);\n    logk = logkw - S1 * fi / (1 + 10^logS2 * fi);\n    \n    return logk;\n  }\n}\n\ndata{\n  int nAnalytes;\t// number of analytes\n  int nObs;\t\t\t// number of observations\n  int analyte[nObs];\t\t// analytes indexes\n  int start[nAnalytes];\t\t// first apperance of analyte in \"analyte\" vector\n  vector[nObs] logkObs;\t    // observed retention factors\n  vector[nObs] fi;         // organic modifier content in the mobile phase\n  real Mmolx[nObs];         // (moleculuar mass-300)/100\n  int<lower=0> K;           //  number of predictors (functional groups)\n  matrix[nAnalytes, K] nrfungroups;   // predictor matrix (functional groups)   \n  int<lower = 0, upper = 1> run_estimation; // 0 for prior predictive, 1 for estimation\n}\n\nparameters{\n\n real logkwHat;\t// mean value of logkw \n real logkaHat; // mean value of logka \n real logS2Hat;\t// mean curvature coefficient \n real<lower = 0> sigma;\t\t// standard deviation for residuals\n vector<lower = 0>[3] omega;// diagonal elements of variance-covariance matrix for inter-analyte variability \n corr_matrix[3] rho;\t    // correlation matrix\t\t\n real<lower = 1> nu;\t    // normality constant for inter-analyte variability \n real<lower = 1> nuobs;     // normality constant for residual variability \n real<lower = 1> nupi;     // normality constant for residual variability \n real beta[3];\t\t\t    // regression coefficients for Mmolx\n vector[3] param[nAnalytes]; // individual values of chromatographic parameters\n vector<lower = 0>[K] pilogkw;  // regression coefficient for logkw\n vector[K] pidlogk ;  //... logka logkw difference\n vector[K] pilogS2;             // ... logS2\n real<lower = 0> spilogkw;      // group-level std for logkw\n real<lower = 0> spidlogk;      //... logka\n real<lower = 0> spilogS2;      //... logS2\n real<lower = 0> mpilogkw;      // group-level mean for logkw\n real mpidlogk;      //... logka\n}\n\ntransformed parameters{\n  vector[3] miu[nAnalytes];\t \n  real logka[nAnalytes];\n  real logkw[nAnalytes];\n  real logS2[nAnalytes];\n  vector[K] pilogka;\n  cov_matrix[3] Omega;\t\t\t // variance-covariance matrix\n  vector[nObs] logkHat;\t\t\n\n  Omega = quad_form_diag(rho, omega);\t// diag_matrix(omega) * rho * diag_matrix(omega)\n\n  pilogka = pilogkw - pidlogk;\n\n  for(j in 1:nAnalytes){\n    miu[j,1]  = logkwHat + beta[1] * Mmolx[start[j]] - nrfungroups[j,1:K] * pilogkw;\n    miu[j,2]  = logkaHat + beta[2] * Mmolx[start[j]] - nrfungroups[j,1:K] * pilogka; \n    miu[j,3]  = logS2Hat + beta[3] * Mmolx[start[j]] + nrfungroups[j,1:K] * pilogS2;\n  }\n\n  for(j in 1:nAnalytes){\n\t\tlogkw[j] = param[j, 1];\n\t\tlogka[j] = param[j, 2];\n\t\tlogS2[j] = param[j, 3];\n }\n  \n  for(i in 1:nObs){\n    logkHat[i] = hplcmodel(fi[i], logkw[analyte[i]], logka[analyte[i]], logS2[analyte[i]]);\n }\n}\nmodel{\n  logkwHat ~ normal(6.6, 1.5);  //3.6+2*1.5\n  logkaHat ~ normal(1.3, 1.5); //-1.7+2*1.5\n  logS2Hat ~ normal(log10(2), 0.2);\n\n  beta[1]  ~ normal(1.4,1.5);\n  beta[2]  ~ normal(0.2,1.5);\n  beta[3]  ~ normal(0,0.2);\n\n  omega[1] ~ normal(0,1.50);\n  omega[2] ~ normal(0,1.50);\n  omega[3] ~ normal(0,0.2);\n\n  rho   ~ lkj_corr(1);\n  sigma  ~ normal(0,0.067);\n\n  mpilogkw ~ normal(0,1.5);\n  mpidlogk ~ normal(0,1.5);\n  \n  spilogkw ~ normal(0,1.5);\n  spidlogk ~ normal(0,1.5);\n  spilogS2 ~ normal(0,0.2);\n\n  pilogkw ~ lognormal(log(mpilogkw),spilogkw);\n  pidlogk ~ student_t(nupi,mpidlogk,spidlogk);\n  pilogS2 ~ normal(0,spilogS2);\n\n  nu    ~ gamma(2,0.1);\n  nuobs ~ gamma(2,0.1);\n  nupi  ~ gamma(2,0.1);\n\n  for(i in  1:nAnalytes){\n  param[i] ~ multi_student_t(nu,miu[i],Omega);\n  }\n  \n  if(run_estimation==1){\n  logkObs ~ student_t(nuobs,logkHat,sigma); // likelihood\n  }\n}\n\ngenerated quantities{\n  real logkCond[nObs];\n  real logkPred[nObs];\n  //real log_lik[nObs];\n  vector[3] paramPred[nAnalytes]; \n  \n  for(j in 1:nAnalytes){\n   paramPred[j] = multi_student_t_rng(nu,miu[j],Omega);\n  }\n  \n  for(i in 1:nObs){\n   real logkHatPred;\t// predicted logk\t\n   logkHatPred = hplcmodel(fi[i], paramPred[analyte[i],1], paramPred[analyte[i],2], paramPred[analyte[i],3]);\n   logkCond[i] = student_t_rng(nuobs, logkHat[i], sigma);\n   logkPred[i] = student_t_rng(nuobs, logkHatPred, sigma);\n   //log_lik[i]= student_t_lpdf(logkObs[i] | nuobs, logkHat[i], sigma);\n  }\n}\n```\n:::\n\n\nThen, the data was added to it and the initial values of the model parameters were determined. In the end, the model was fitted.\n\nBelow code preapering data to fit the model in supercomputer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages\nlibrary(pracma)\nlibrary(dplyr)\nlibrary(ggplot2)\nrequire(gridExtra)\nlibrary(GGally)\nlibrary(cmdstanr)\nlibrary(rstan)\nlibrary(knitr)\nlibrary(reshape2)\nlibrary(bayesplot)\nlibrary(posterior)\n\n# load data\nDS       <- read.csv(here::here(\"1_data/database_stan_1026.csv\"),header = TRUE, sep = \";\", dec = \".\")\nDS_names <- read.csv(here::here(\"1_data/database_stan_1026_analyte_names.csv\"),header = TRUE, sep = \",\", dec = \".\")\nfunctional_groups         <- read.csv(here::here(\"1_data/checkmol_nr_groups.csv\"),header = TRUE, sep = \",\", dec = \".\")\nfunctional_groups_names   <- read.delim(here::here(\"1_data/checkmol_functional_group_names.csv\"),header = TRUE, sep = \";\", dec = \".\")\n\n### prepearing data with functional groups\nfunctional_groups[,76]=functional_groups[,76]+functional_groups[,77]       \nfunctional_groups[which(functional_groups[,202]>8.1),202] = 8; # heterocyclic compounds with more than 8 heterocycles are treated as if they have eigth\n\nidx_excluded <- c(1, 2, 3, 6, 27, 28, 37, 47, 48, 51, 55, 61, 62, 67, 73, 74, 75, 77, 80, 91, 99, 109, 116, 117, 121, 125, 129, 142, 153, 154, 160, 161, 168, 173, 178, 181, 182, 186, 187, 191, 196)\nfunctional_groups <- functional_groups[,-idx_excluded]\nfunctional_groups_names <- functional_groups_names[-idx_excluded,]\n\nidx_not_present = which(colSums(functional_groups==0) == nrow(functional_groups))\nfunctional_groups <- functional_groups[,-idx_not_present]\nfunctional_groups_names <- functional_groups_names[-idx_not_present,]\n\nnAnalytes=length(unique(DS$ID))\nnObs=length(DS$ID)\nanalyte=match(DS$ID, unique(DS$ID))\nstart=which(!duplicated(DS$ID))\nK=ncol(functional_groups)\nMmolx=(DS$MW_ACD-300)/100\nnrfungroups=functional_groups\nlogkObs=DS$logk\nfi=DS$concentration\nrun_estimation=1\n\nstan_rdump(c(\"nAnalytes\", \n             \"nObs\",\n             \"start\", \n             \"analyte\", \n             \"logkObs\", \n             \"fi\",\n             \"K\",\n             \"nrfungroups\",\n             \"Mmolx\",\n             \"run_estimation\"),\n           file=\"2_model/model.data.R\")\n\ninitial_param_A <- matrix(NA,nAnalytes,2)\nfor(i in 1:nAnalytes){\n  initial_param_A[i,] = \n    polyfit(DS$concentration[which(DS$ID==i)]/(1+2*DS$concentration[which(DS$ID==i)]),\n            DS$logk[which(DS$ID==i)],1)\n}\ninitial_param_A = cbind(initial_param_A,rep(2,nAnalytes))\nparam = cbind(initial_param_A[,2], initial_param_A[,2] + initial_param_A[,1]/3, log10(initial_param_A[,3]))\n\nfor(i in 1:10){\n  logkwHat  =  rnorm(1,6.6,1)\n  logkaHat  = rnorm(1,1.3,1)\n  logS2AHat = rnorm(1,log(2),0.1)\n  beta = c(1.4,0.2,0)*exp(rnorm(3,0,1))\n  rho = diag(1,3,3)\n  sigma =rlnorm(1,log(0.05),0.2)\n  nu = rgamma(1,2,1/0.1)\n  nuobs = rgamma(1,2,1/0.1)\n  nupi = rgamma(1,2,1/0.1)\n  pilogkw = rlnorm(K,log(0.2),0.5)\n  pidlogk = rnorm(K,0.2, 0.5)\n  pilogS2 = rnorm(K,0, 0.1)\n  omega= c(1,1,0.1)*exp(rnorm(3,0,0.2))\n  spilogkw= abs(rnorm(1,0,0.5))\n  spidlogk= abs(rnorm(1,0,0.5))\n  spilogS2= abs(rnorm(1,0,0.5))\n  mpilogkw = abs(rnorm(1,0,0.5))\n  mpidlogk = rnorm(1,0,0.5)\n  param  = param\n  \n  stan_rdump(c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta\",\"rho\",\"sigma\",\n               \"nu\",\"nuobs\",\"nupi\",\"pilogkw\",\"pidlogk\",\"pilogS2\",\"omega\",\n               \"spilogkw\",\"spidlogk\",\"spilogS2\",\"mpilogkw\",\"mpidlogk\",\"param\"),\n             file=paste(\"2_model/model_\", i, \".init.R\", sep=\"\"))\n}\n```\n:::\n\n\n## Summary of model parameters\n\nCode for print summary of parameters from supercomputer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- cmdstanr::as_cmdstan_fit(c('2_model/output_1.csv',\n                                  '2_model/output_2.csv',\n                                  '2_model/output_3.csv',\n                                  '2_model/output_4.csv',\n                                  '2_model/output_5.csv',\n                                  '2_model/output_6.csv',\n                                  '2_model/output_7.csv',\n                                  '2_model/output_8.csv',\n                                  '2_model/output_9.csv',\n                                  '2_model/output_10.csv'))\n\nfit$print(c(\"logkwHat\",\"logkaHat\",\"logS2AHat\",\"beta\",\"rho\",\"sigma\",\"nu\",\"nuobs\",\"nupi\",\"omega\",\n            \"spilogkw\",\"spidlogk\",\"spilogS2\",\"mpilogkw\",\"mpidlogk\"), max_rows = 26)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}